# 为什么仅靠 VibeCoding 很难构建复杂系统

这两年，AI 编程工具的变化肉眼可见：
从“自动补全几行代码”，变成了“你开口描述需求，它帮你把东西写出来”。

在不少讨论里，这种 **“主要用自然语言描述，AI 负责写代码，自己基本不看代码”** 的方式，被 Andrej Karpathy（OpenAI 联合创始人、前特斯拉 AI 负责人）称为 **Vibe coding**，大致意思是：

> 把自己完全交给“vibes”，忘掉代码细节，和模型对话就行。([Wikipedia][1])

很多 Demo 视频、播客访谈、甚至大厂高管的表述，也都是围绕这类方式在展开。

在原型、一次性脚本、逻辑不复杂的小产品上，这种方式非常好用，我自己也经常用。
但对于那种**有一定复杂度、而且打算长期维护的系统**，我的看法是：

> **仅靠这种方式，很难把系统做扎实。**

不是因为 AI 不够聪明，也不是因为“人必须手写代码才算认真”，
而是因为：**系统除了功能，还有一层“结构”，而这类工作流里，结构往往缺少被确认和长期维护的机制。**

下面我分几层说说为什么。

---

## 一、系统不只有功能，还有一层“结构”

很多宣传里的系统，看起来就像是一串功能列表：

* 能注册登录
* 能下单支付
* 能看报表
* 能导出数据

从产品视角看没问题。
但从工程视角，一个系统至少有两层：

1. **功能层**：对外到底能做什么。
2. **结构层**：这些能力在系统内部，是通过什么样的程序元素组织方式实现的。

在这篇文章里，我说的「结构」，指的是：

> **系统内部程序元素（模块、接口、数据、状态）的组织和连接方式，**
> 也就是功能之外，这些东西“是怎么被摆放和组合起来”的。

很多人潜意识里的模型是：

> “只要有足够时间和人力，功能总能写出来，结构好不好只是优不优雅。”

我的经验是：
**有些能力，在随便堆出来的结构上根本长不起来。**

举个很日常的例子：
一个“导出报表”的功能看上去很简单。但如果：

* 权限规则散落在各个接口里；
* 数据来自三个服务，汇总逻辑写在前端；
* 时间区间、时区、汇率都混在一起处理；

你会发现这个“导出报表”功能做是能做，但任何一个新需求（比如：加一列、改个过滤条件），都可能牵一大串东西。
而如果一开始把：

* 权限关口
* 数据聚合位置
* 汇总和展示分层
* 时间/货币等横切概念

放在一个相对合理的结构上，**同样是“导出报表”，体验就不一样了。**

这有点像算法和数据结构的关系：

* 从理论上，很多事情都可以只用数组硬做；
* 但有些能力，必须建立在合适的数据结构上（树、图、索引），才算真正“长出来”。

系统内部的结构也是这样：

* 有些功能，在任意结构下是“勉强能做”；
* 只有在合适的结构上，它才会成为一种自然、稳定、可演化的解。

所以对我来说，“结构”不是为了好看，而是：

> **有些功能，本身就是在特定结构上的解。
> 如果没有那个结构，这类功能要么做不出来，要么会以一种很别扭的方式存在。**

---

## 二、结构性的决策：不仅是“大架构”，还有无数微小选择

说到结构，大家容易想到几张大图：

* 分层架构图
* 服务拓扑图
* 组件依赖图……

这些当然重要，但在实际写代码时，大量结构感是从一堆**微小的决策**堆出来的。

比如：

* 这段逻辑放在 controller 里，还是下沉到 domain/service？
* 是复用已有接口的一个“模式”，还是拆出一个更合理的新接口？
* 这个状态由谁持有：调用方，还是被调用方？
* 这个功能依赖现有模块，还是拉一个独立模块，防止以后越来越黏？
* 数据转换是在入口统一做，还是在各自模块内部分散做？

这些决策很少被写在“宏大架构文档”里，但久而久之，就变成系统真正的性格。

在传统的开发方式里，这些选择往往依赖于：

* 你对现有系统结构和历史包袱的理解；
* 你对这个系统未来大概怎么长的预感；
* 以及一些“这地方如果耦合过度，未来会很难收拾”的直觉。

而在那种**只用自然语言讲需求、让 AI 自动帮你“搞定细节”**的工作流里，这些结构性的小选择，会发生一个悄悄的变化：

* 这些本来需要结合“当前系统限制”做判断的决定，**被自动交给模型来选**；
* 模型会给你一个“看上去很合理的通用答案”，
  通常也是它在无数普通项目里学到的那一套；
* 但它并不了解你这个具体系统的脾气 —— 旧债务在哪儿、哪些边不能碰、以后可能往哪边长。

结果是：

* 单看任何一个点，似乎都说得过去；
* 但这些和当前系统不完全贴合的“小偏差”，会一点点累积成结构上的大偏离。

所以我更担心的不是：

> “AI 写这段代码会不会报错？”

而是：

> **如果每一个结构性的小选择都交给一个“通用默认值”，
> 那么对复杂系统来说，它的结构会慢慢变得说不清、理不顺。**

---

## 三、「一句话 Demo」和简单产品：价值是真实存在的

说到这里，很容易被理解成我是在“反对”这种方式。
其实不是的。

在一些逻辑不复杂的场景里，它已经非常好用，而且确实改变了不少人的工作方式。

例如：

* 有一些小工具、小后台、简单的数据看板，以前必须找程序员排期；
* 现在一个业务人员、产品、运营，只要知道自己要什么，
  基本可以通过和 AI 对话，把一个可用版本做出来；
* 打磨一下交互、稍微多测几轮，很多场景下就可以直接上线用。

这些产品不一定复杂，但是真实在解决问题、创造价值。
从这个角度说，这类方式确实拓展了很多人的能力边界，这是事实，不需要额外渲染。

各种场合出现的“一句话生成 App”、“一段描述生成页面”的 Demo，
大多也属于这一类：场景封闭、约束有限、生命周期未必很长。

对这类系统来说：

> **没有那么多结构上的长期负担，
> 能跑、好改、上线，就已经很有意义。**

但当系统开始变复杂、引入更多外部依赖、积累历史数据、打算跑很多年时，
问题就不再只是“能不能做出来”，而是：

> **“它以后怎么改，谁来改，改到什么程度不会一脚踩塌半个系统？”**

这时候，结构就会慢慢浮出水面。

---

## 四、目前我在用的一种协作方式

在复杂系统里，如果还想大量用 AI，我现在看到、自己也在用的，大致都是同一种协作方式：

> **每次做一个功能，先和 AI 讨论设计和方案，确认之后，再让它去实现。**

不是一句话“帮我做个 X”就完事，而是多几步：

* 先把需求、约束、现有系统状况说清楚；
* 让 AI 给出几种设计思路，讨论各自优缺点；
* 对模块划分、接口形态、数据流、大致边界先达成一个约定，再开始写代码。

有些团队会在这个基础上，把和 AI 讨论出来的设计说明、权衡过程整理出来，长期保存为“系统映射”，希望为之后的迭代提供参考。

我对这一步是有点保留的：

* 系统真正的状态，最终还是由那份正在跑的代码决定；
* 文档在几轮迭代之后，很容易过时；
* 下一次再让 AI 按照这些旧文档继续实现，很可能会生成和上一次不一样的结构。

所以我现在的做法是：

* 流程上，还是先和 AI 讨论设计，再让它实现；
* 但在“系统的真实样子”这件事上，**我只承认代码这一层。**

这意味着一些工程手段是绕不过去的：

* 在开发过程中就顺手 review 一眼产出的代码结构，而不是只看设计稿；
* 把功能开发拆成很小的步子：一两个 commit 解决一个点；
* 功能能跑之后，刻意留出一个“小重构循环”，专门做一件事：

  * 把刚写出的那块逻辑整理干净，
  * 控制模块复杂度，把局部熵压下去；
* 用单元测试、lint、type-check 等工具，把结构和行为尽可能变成自动化约束。

简单说：

> 我会用 AI 把“功能做出来”这一步加速，
> 但仍然用工程手段，亲自守住**代码这一层的结构和质量**，
> 而不会把这些完全托付给一份难以长期同步的文档。

---

## 五、我现在是怎么用这类方式的？

如果按复杂度粗分，我现在大概是这样用的：

### 1. 对于不那么复杂、生命周期不长的产品

* 业务逻辑简单、场景清晰；
* 不打算运营很多年，更多是验证想法或解决局部问题；

在这种情况下，我觉得：

> **用 VibeCoding 式的方式，从需求到上线跑一遍，完全合理。**

这类场景下，“自然语言 → App” 可以直接承担从想法到落地的全流程。

### 2. 对于复杂、需要长期演化的系统

我会分两步来用 AI：

**第一步：用 AI 快速「探路」**

* 用偏 Vibe 的方式，让 AI 先“按直觉”帮我实现一版；
* 目的不是直接投入生产，而是：

  * 快速看到问题空间的真实形状；
  * 看看有哪些我没想到的边界和约束；
  * 看看和现有系统有哪些不太理想的耦合点；
* 默认这个版本是随时可以扔掉的，它更像是一个**探索草稿**。

**第二步：在看清问题后，按结构真正建一次**

* 基于前面的探索结果，把结构这一层认真捋一遍：

  * 大致有哪些模块？各自职责是什么？
  * 数据和状态如何分布、怎样流？
  * 哪些地方应该非常稳定，哪些地方以后会频繁变动？
* 用这些结论当作“骨架”，再让 AI 在其上生成真正要维护的代码；
* 在这个过程中：

  * 大部分代码还是 AI 写；
  * 但我会参与关键结构决策，以及不少看似细碎但实际很关键的微决策；
* 然后用测试、重构、工具，把这份实现守在一个我能接受的复杂度和质量范围内。

这不是“最佳实践”，
只能说：**在今天这个时间点，对我来说，这是比较自然、也比较踏实的一条路。**

---

## 结语：在当下这个阶段，我会这样划边界

回到标题里的问题：

> 为什么仅靠 VibeCoding，很难构建复杂系统？

我的阶段性理解是：

* 系统不只有功能，还有一层程序元素的组织方式，也就是结构；
* 有些功能，本身就是在特定结构上的解，换一种结构就“长不出来”；
* 在复杂系统里，从宏观到微观有大量结构性决策，都和当前系统的限制紧密相关；
* 如果把这些决策全部交给“通用默认选项”，系统短期内可以跑起来，但长期演化时会越来越难以掌控。

在今天这个阶段：

* AI 还不能真正理解现实世界中的所有细节与限制；
* 我们和它交流的主要方式，还是自然语言 + 已有代码、文档；

在这样的前提下，**我不会把复杂系统从头到尾完全交给 VibeCoding 这种方式独自完成。**

相反，我更愿意这样划一条边界：

* **简单系统**：

  * 逻辑清晰、约束有限、生命周期不长的产品，
  * 尽情利用 VibeCoding 带来的效率和门槛降低就好。
* **复杂系统**：

  * 有很多限制、需要长期维护的系统，
  * 把这类方式当成一个非常好的加速器，
  * 但在结构决策和代码质量上，仍然保留一层工程手段和人的参与。

至少在现在，面对这类系统时，我会在享受 AI 带来效率的同时，刻意多做一件事：

> **亲自过一遍系统的结构，
> 参与那些看起来细碎，但从长期看很关键的决策。**

这大概就是我目前的理解。
等将来环境变了，也许这篇文章本身就应该被“重构”一次。

[1]: https://en.wikipedia.org/wiki/Vibe_coding?utm_source=chatgpt.com "Vibe coding"
