{:path [], :nextjournal/value {:package :directory, :toc {:path [], :nextjournal/value [], :nextjournal/render-opts {:toc-visibility false, :set-hash? true}, :nextjournal/viewer {:name nextjournal.clerk.viewer/toc-viewer, :render-fn #clerk/render-fn+opts [{:render-evaluator :sci} nextjournal.clerk.render.navbar/render-items], :hash "5dtesrAmYqLZQQHSMEfFTNpmLtY4nC"}}, :sidenotes? false, :toc-visibility false, :atom-var-name->state {}, :ns #clerk/render-fn+opts [{:eval true} (ns pages.branchless)], :file "pages/branchless.clj", :scope pages.branchless, :header {:path [], :nextjournal/value [:div.viewer.w-full.max-w-prose.px-8.not-prose.mt-3 [:div.mb-8.text-xs.sans-serif.text-slate-400 nil [:<> [:a.font-medium.border-b.border-dotted.border-slate-300.hover:text-indigo-500.hover:border-indigo-500.dark:border-slate-500.dark:hover:text-white.dark:hover:border-white.transition {:href "./../../"} "Index"] [:span.mx-2 "•"]] [:span "Generated with " [:a.font-medium.border-b.border-dotted.border-slate-300.hover:text-indigo-500.hover:border-indigo-500.dark:border-slate-500.dark:hover:text-white.dark:hover:border-white.transition {:href "https://clerk.vision"} "Clerk"] [:<> " from " [:a.font-medium.border-b.border-dotted.border-slate-300.hover:text-indigo-500.hover:border-indigo-500.dark:border-slate-500.dark:hover:text-white.dark:hover:border-white.transition {:href "https://github.com/bencode/LambdaCraft/blob/f7b31df3a2bd3fe9512af0281dfa335ec3965f4d/apps/web/pages/branchless.clj"} "pages/branchless.clj" [:<> "@" [:span.tabular-nums "f7b31df"]]]]]]], :nextjournal/viewer {:name nextjournal.clerk.viewer/html-viewer, :render-fn #clerk/render-fn+opts [{:render-evaluator :sci} nextjournal.clerk.render/render-html], :hash "5drpr3yzJ1CcHNbRHnK2sVyn7YUmXB"}}, :open-graph {:type "article:clerk"}, :blocks [{:path [], :nextjournal/value [{:path [0], :nextjournal/value {:nextjournal/presented {:path [0], :nextjournal/value [:div.viewer.markdown-viewer.w-full.max-w-prose.px-8 {:data-block-id nil} ["h1" {:id "我把分支“藏”进了函数：typescript-的-final-encoding，顺路聊聊-clojure"} [:<> "我把分支“藏”进了函数：TypeScript 的 final encoding，顺路聊聊 Clojure"]] [:p [:strong [:<> "语言的边界，即思维的边界"]] [#clerk/render-fn+opts [{:eval true} nextjournal.clerk.render/inspect-presented] {:nextjournal/value [:<> " "], :nextjournal/viewer {:name nextjournal.clerk.viewer/html-viewer, :render-fn #clerk/render-fn+opts [{:render-evaluator :sci} nextjournal.clerk.render/render-html], :hash "5drpr3yzJ1CcHNbRHnK2sVyn7YUmXB"}}] [:em [:<> "——一个程序员关于表达式与语言的自言自语"]]] [:p [:<> "最近我又在想那个老问题：怎么优雅地表示一棵表达式树？"] [#clerk/render-fn+opts [{:eval true} nextjournal.clerk.render/inspect-presented] {:nextjournal/value [:<> " "], :nextjournal/viewer {:name nextjournal.clerk.viewer/html-viewer, :render-fn #clerk/render-fn+opts [{:render-evaluator :sci} nextjournal.clerk.render/render-html], :hash "5drpr3yzJ1CcHNbRHnK2sVyn7YUmXB"}}] [:<> "一个算式，比如："]] [#clerk/render-fn+opts [{:eval true} nextjournal.clerk.render/inspect-presented] {:nextjournal/value [:div.code-viewer.code-listing [#clerk/render-fn+opts [{:eval true} nextjournal.clerk.render/inspect-presented] {:path [0], :nextjournal/value "f(x) = (x + 2) * (x + 3)^2 - sin(x)", :nextjournal/render-opts {:language "clojure"}, :nextjournal/viewer {:name nextjournal.clerk.viewer/code-viewer, :render-fn #clerk/render-fn+opts [{:render-evaluator :sci} nextjournal.clerk.render/render-code], :hash "5dsJQw12yyyd7TcZEf52VSHxnqnJUC"}}]], :nextjournal/viewer {:name nextjournal.clerk.viewer/html-viewer, :render-fn #clerk/render-fn+opts [{:render-evaluator :sci} nextjournal.clerk.render/render-html], :hash "5drpr3yzJ1CcHNbRHnK2sVyn7YUmXB"}}] [:p [:<> "这问题太老了，几乎所有语言的教程都会提。可每次重写，我总觉得哪里不对。我写的不是计算，而是在和"] [:strong [:<> "语言本身的抽象能力较劲"]] [:<> "。"]] ["h3" {:id "1.-我们都从分支开始"} [:<> "1. 我们都从分支开始"]] [:p [:<> "老办法嘛，一棵树，一个 "] [:code [:<> "tag"]] [:<> "，一个 "] [:code [:<> "switch"]] [:<> "。代码很直觉，也很稳："]] [#clerk/render-fn+opts [{:eval true} nextjournal.clerk.render/inspect-presented] {:nextjournal/value [:div.code-viewer.code-listing [#clerk/render-fn+opts [{:eval true} nextjournal.clerk.render/inspect-presented] {:path [0], :nextjournal/value "// 传统 AST：判别联合\ntype Expr =\n  | { tag: 'Num'; n: number }\n  | { tag: 'Var'; name: string }\n  | { tag: 'Add'; a: Expr; b: Expr }\n  | { tag: 'Mul'; a: Expr; b: Expr }\n  | { tag: 'Neg'; x: Expr }\n  | { tag: 'Pow'; a: Expr; b: Expr }\n  | { tag: 'Sin'; x: Expr }\n  | { tag: 'Cos'; x: Expr };\n\nfunction evalExpr(e: Expr, env: Record<string, number>): number {\n  switch (e.tag) {\n    case 'Num': return e.n;\n    case 'Var': return env[e.name];\n    case 'Add': return evalExpr(e.a, env) + evalExpr(e.b, env);\n    case 'Mul': return evalExpr(e.a, env) * evalExpr(e.b, env);\n    case 'Neg': return -evalExpr(e.x, env);\n    case 'Pow': return Math.pow(evalExpr(e.a, env), evalExpr(e.b, env));\n    case 'Sin': return Math.sin(evalExpr(e.x, env));\n    case 'Cos': return Math.cos(evalExpr(e.x, env));\n  }\n}", :nextjournal/render-opts {:language "ts"}, :nextjournal/viewer {:name nextjournal.clerk.viewer/code-viewer, :render-fn #clerk/render-fn+opts [{:render-evaluator :sci} nextjournal.clerk.render/render-code], :hash "5dsJQw12yyyd7TcZEf52VSHxnqnJUC"}}]], :nextjournal/viewer {:name nextjournal.clerk.viewer/html-viewer, :render-fn #clerk/render-fn+opts [{:render-evaluator :sci} nextjournal.clerk.render/render-html], :hash "5drpr3yzJ1CcHNbRHnK2sVyn7YUmXB"}}] [:p [:<> "但每当我想加一个新节点，比如 "] [:code [:<> "Div"]] [:<> "、"] [:code [:<> "Ln"]] [:<> "、"] [:code [:<> "Exp"]] [:<> "，我就要在 "] [:strong [:<> "所有操作"]] [:<> " 里再加一堆分支："] [:code [:<> "eval"]] [:<> "、"] [:code [:<> "print"]] [:<> "、"] [:code [:<> "simplify"]] [:<> "、"] [:code [:<> "diff"]] [:<> "……它们像影子一样紧紧跟着我。"]] [:p [:<> "这时候我会想起一个老朋友："] [:strong [:<> "Expression Problem"]] [:<> "——"]] [:blockquote [:p [:<> "想加「新节点」，要改所有「操作」；"] [#clerk/render-fn+opts [{:eval true} nextjournal.clerk.render/inspect-presented] {:nextjournal/value [:<> " "], :nextjournal/viewer {:name nextjournal.clerk.viewer/html-viewer, :render-fn #clerk/render-fn+opts [{:render-evaluator :sci} nextjournal.clerk.render/render-html], :hash "5drpr3yzJ1CcHNbRHnK2sVyn7YUmXB"}}] [:<> "想加「新操作」，要改所有「节点」。"]]] [:p [:<> "我在这里卡了很多年。"]] ["h3" {:id "2.-如果换个角度看呢？"} [:<> "2. 如果换个角度看呢？"]] [:p [:<> "有一天，我看到 "] [:strong [:<> "final encoding/branchless"]] [:<> "。有人说：“"] [:strong [:<> "不写分支，也能表达分支"]] [:<> "”。听起来有点玄，但核心就一句话——"] [:strong [:<> "让表达式自己知道该调用谁"]] [:<> "。"]] [:p [:<> "我试着在 TypeScript 里照猫画虎。"]] [#clerk/render-fn+opts [{:eval true} nextjournal.clerk.render/inspect-presented] {:nextjournal/value [:div.code-viewer.code-listing [#clerk/render-fn+opts [{:eval true} nextjournal.clerk.render/inspect-presented] {:path [0], :nextjournal/value "// 一个表达式：给我一个“解释器”（一张函数表），我产出一个 R\ntype ExprF = <R>(alg: Alg<R>) => R;\n\n// 你支持哪些节点，就在解释器表里列出这些处理器\ntype Alg<R> = {\n  const: (n: number) => R;\n  var:   (name: string) => R;\n  add:   (x: R, y: R) => R;\n  mul:   (x: R, y: R) => R;\n  neg:   (x: R) => R;\n  pow:   (x: R, y: R) => R;\n  sin:   (x: R) => R;\n  cos:   (x: R) => R;\n};\n\n// 构造器：表达式本身就是“等你传入 alg 的函数”\nconst Const = (n: number): ExprF => alg => alg.const(n);\nconst VarF  = (name: string): ExprF => alg => alg.var(name);\nconst AddF  = (x: ExprF, y: ExprF): ExprF => alg => alg.add(x(alg), y(alg));\nconst MulF  = (x: ExprF, y: ExprF): ExprF => alg => alg.mul(x(alg), y(alg));\nconst NegF  = (x: ExprF): ExprF => alg => alg.neg(x(alg));\nconst PowF  = (x: ExprF, y: ExprF): ExprF => alg => alg.pow(x(alg), y(alg));\nconst SinF  = (x: ExprF): ExprF => alg => alg.sin(x(alg));\nconst CosF  = (x: ExprF): ExprF => alg => alg.cos(x(alg));\n\nconst run = <R>(e: ExprF, alg: Alg<R>): R => e(alg);", :nextjournal/render-opts {:language "ts"}, :nextjournal/viewer {:name nextjournal.clerk.viewer/code-viewer, :render-fn #clerk/render-fn+opts [{:render-evaluator :sci} nextjournal.clerk.render/render-code], :hash "5dsJQw12yyyd7TcZEf52VSHxnqnJUC"}}]], :nextjournal/viewer {:name nextjournal.clerk.viewer/html-viewer, :render-fn #clerk/render-fn+opts [{:render-evaluator :sci} nextjournal.clerk.render/render-html], :hash "5drpr3yzJ1CcHNbRHnK2sVyn7YUmXB"}}] [:p [:<> "这时，表达式不再是“数据”，而是一种"] [:strong [:<> "等待被解释的行为"]] [:<> "。"] [#clerk/render-fn+opts [{:eval true} nextjournal.clerk.render/inspect-presented] {:nextjournal/value [:<> " "], :nextjournal/viewer {:name nextjournal.clerk.viewer/html-viewer, :render-fn #clerk/render-fn+opts [{:render-evaluator :sci} nextjournal.clerk.render/render-html], :hash "5drpr3yzJ1CcHNbRHnK2sVyn7YUmXB"}}] [:<> "求值？传入 "] [:code [:<> "evalAlg"]] [:<> "。打印？传入 "] [:code [:<> "printAlg"]] [:<> "。化简与求导？再各自写一套解释器即可。"]] [:p [:strong [:<> "神奇之处在于"]] [:<> "：任何时候，我都没有写 "] [:code [:<> "switch"]] [:<> "。分支被“吸收”进了高阶函数。"]] ["h3" {:id "3.-我把它跑起来（eval/print/simplify/diff）"} [:<> "3. 我把它跑起来（eval/print/simplify/diff）"]] [:p [:strong [:<> "求值解释器："]]] [#clerk/render-fn+opts [{:eval true} nextjournal.clerk.render/inspect-presented] {:nextjournal/value [:div.code-viewer.code-listing [#clerk/render-fn+opts [{:eval true} nextjournal.clerk.render/inspect-presented] {:path [0], :nextjournal/value "const evalAlg = (env: Record<string, number>): Alg<number> => ({\n  const: n => n,\n  var  : name => {\n    if (!(name in env)) throw new Error(`Unbound var: ${name}`);\n    return env[name];\n  },\n  add  : (x, y) => x + y,\n  mul  : (x, y) => x * y,\n  neg  : x => -x,\n  pow  : (x, y) => Math.pow(x, y),\n  sin  : x => Math.sin(x),\n  cos  : x => Math.cos(x),\n});", :nextjournal/render-opts {:language "ts"}, :nextjournal/viewer {:name nextjournal.clerk.viewer/code-viewer, :render-fn #clerk/render-fn+opts [{:render-evaluator :sci} nextjournal.clerk.render/render-code], :hash "5dsJQw12yyyd7TcZEf52VSHxnqnJUC"}}]], :nextjournal/viewer {:name nextjournal.clerk.viewer/html-viewer, :render-fn #clerk/render-fn+opts [{:render-evaluator :sci} nextjournal.clerk.render/render-html], :hash "5drpr3yzJ1CcHNbRHnK2sVyn7YUmXB"}}] [:p [:strong [:<> "打印解释器（带简单优先级）："]]] [#clerk/render-fn+opts [{:eval true} nextjournal.clerk.render/inspect-presented] {:nextjournal/value [:div.code-viewer.code-listing [#clerk/render-fn+opts [{:eval true} nextjournal.clerk.render/inspect-presented] {:path [0], :nextjournal/value "type Printed = { s: string; p: number };\nconst paren = (need: boolean, s: string) => (need ? `(${s})` : s);\n\nconst printAlg = (): Alg<Printed> => ({\n  const: n => ({ s: String(n), p: 100 }),\n  var  : name => ({ s: name, p: 100 }),\n  neg  : x => ({ s: `-${paren(x.p < 90, x.s)}`, p: 95 }),\n  pow  : (x, y) => ({ s: `${paren(x.p < 99, x.s)}^${paren(y.p <= 99, y.s)}`, p: 99 }),\n  mul  : (x, y) => ({ s: `${paren(x.p < 98, x.s)} * ${paren(y.p < 98, y.s)}`, p: 98 }),\n  add  : (x, y) => ({ s: `${paren(x.p < 97, x.s)} + ${paren(y.p < 97, y.s)}`, p: 97 }),\n  sin  : x => ({ s: `sin(${x.s})`, p: 100 }),\n  cos  : x => ({ s: `cos(${x.s})`, p: 100 }),\n});\nconst printF = (e: ExprF): string => run(e, printAlg()).s;", :nextjournal/render-opts {:language "ts"}, :nextjournal/viewer {:name nextjournal.clerk.viewer/code-viewer, :render-fn #clerk/render-fn+opts [{:render-evaluator :sci} nextjournal.clerk.render/render-code], :hash "5dsJQw12yyyd7TcZEf52VSHxnqnJUC"}}]], :nextjournal/viewer {:name nextjournal.clerk.viewer/html-viewer, :render-fn #clerk/render-fn+opts [{:render-evaluator :sci} nextjournal.clerk.render/render-html], :hash "5drpr3yzJ1CcHNbRHnK2sVyn7YUmXB"}}] [:p [:strong [:<> "化简解释器（常量折叠/零一律）："]]] [#clerk/render-fn+opts [{:eval true} nextjournal.clerk.render/inspect-presented] {:nextjournal/value [:div.code-viewer.code-listing [#clerk/render-fn+opts [{:eval true} nextjournal.clerk.render/inspect-presented] {:path [0], :nextjournal/value "type S = { e: ExprF; c?: number };\nconst SConst = (n: number): S => ({ e: Const(n), c: n });\nconst SExpr  = (e: ExprF): S => ({ e });\n\nconst simplifyAlg = (): Alg<S> => ({\n  const: n => SConst(n),\n  var  : name => SExpr(VarF(name)),\n  neg  : x => (x.c !== undefined ? SConst(-x.c) : SExpr(NegF(x.e))),\n  add  : (x, y) => {\n    if (x.c === 0) return y;\n    if (y.c === 0) return x;\n    if (x.c !== undefined && y.c !== undefined) return SConst(x.c + y.c);\n    return SExpr(AddF(x.e, y.e));\n  },\n  mul  : (x, y) => {\n    if (x.c === 0 || y.c === 0) return SConst(0);\n    if (x.c === 1) return y;\n    if (y.c === 1) return x;\n    if (x.c === -1) return y.c !== undefined ? SConst(-y.c) : SExpr(NegF(y.e));\n    if (y.c === -1) return x.c !== undefined ? SConst(-x.c) : SExpr(NegF(x.e));\n    if (x.c !== undefined && y.c !== undefined) return SConst(x.c * y.c);\n    return SExpr(MulF(x.e, y.e));\n  },\n  pow  : (x, y) => {\n    if (y.c === 0) return SConst(1);\n    if (y.c === 1) return x;\n    if (x.c === 0) return SConst(0);\n    if (x.c === 1) return SConst(1);\n    if (x.c !== undefined && y.c !== undefined) return SConst(Math.pow(x.c, y.c));\n    return SExpr(PowF(x.e, y.e));\n  },\n  sin  : x => (x.c !== undefined ? SConst(Math.sin(x.c)) : SExpr(SinF(x.e))),\n  cos  : x => (x.c !== undefined ? SConst(Math.cos(x.c)) : SExpr(CosF(x.e))),\n});\nconst simplifyF = (e: ExprF): ExprF => run(e, simplifyAlg()).e;", :nextjournal/render-opts {:language "ts"}, :nextjournal/viewer {:name nextjournal.clerk.viewer/code-viewer, :render-fn #clerk/render-fn+opts [{:render-evaluator :sci} nextjournal.clerk.render/render-code], :hash "5dsJQw12yyyd7TcZEf52VSHxnqnJUC"}}]], :nextjournal/viewer {:name nextjournal.clerk.viewer/html-viewer, :render-fn #clerk/render-fn+opts [{:render-evaluator :sci} nextjournal.clerk.render/render-html], :hash "5drpr3yzJ1CcHNbRHnK2sVyn7YUmXB"}}] [:p [:strong [:<> "求导解释器（对变量 "] [:code [:<> "v"]] [:<> "；先支持“幂的常数指数”）："]]] [#clerk/render-fn+opts [{:eval true} nextjournal.clerk.render/inspect-presented] {:nextjournal/value [:div.code-viewer.code-listing [#clerk/render-fn+opts [{:eval true} nextjournal.clerk.render/inspect-presented] {:path [0], :nextjournal/value "type D = { e: ExprF; d: ExprF };\nconst DPair = (e: ExprF, d: ExprF): D => ({ e, d });\n\nconst diffAlg = (v: string): Alg<D> => ({\n  const: n => DPair(Const(n), Const(0)),\n  var  : name => DPair(VarF(name), Const(name === v ? 1 : 0)),\n  neg  : x => DPair(NegF(x.e), NegF(x.d)),\n  add  : (x, y) => DPair(AddF(x.e, y.e), AddF(x.d, y.d)),\n  mul  : (x, y) => DPair(MulF(x.e, y.e), AddF(MulF(x.d, y.e), MulF(x.e, y.d))),\n  pow  : (x, y) => {\n    const ySimpl = run(y.e, simplifyAlg()); // 看 y 是否是常量\n    if (ySimpl.c !== undefined) {\n      const k = ySimpl.c;\n      return DPair(\n        PowF(x.e, y.e),\n        MulF(Const(k), MulF(PowF(x.e, Const(k - 1)), x.d))\n      );\n    }\n    return DPair(PowF(x.e, y.e), Const(Number.NaN)); // 通用规则需要 ln/exp/div 节点\n  },\n  sin  : x => DPair(SinF(x.e), MulF(CosF(x.e), x.d)),\n  cos  : x => DPair(CosF(x.e), NegF(MulF(SinF(x.e), x.d))),\n});\nconst diffF = (e: ExprF, v: string): ExprF => simplifyF(run(e, diffAlg(v)).d);", :nextjournal/render-opts {:language "ts"}, :nextjournal/viewer {:name nextjournal.clerk.viewer/code-viewer, :render-fn #clerk/render-fn+opts [{:render-evaluator :sci} nextjournal.clerk.render/render-code], :hash "5dsJQw12yyyd7TcZEf52VSHxnqnJUC"}}]], :nextjournal/viewer {:name nextjournal.clerk.viewer/html-viewer, :render-fn #clerk/render-fn+opts [{:render-evaluator :sci} nextjournal.clerk.render/render-html], :hash "5drpr3yzJ1CcHNbRHnK2sVyn7YUmXB"}}] [:p [:strong [:<> "把开头那个式子撸一遍："]]] [#clerk/render-fn+opts [{:eval true} nextjournal.clerk.render/inspect-presented] {:nextjournal/value [:div.code-viewer.code-listing [#clerk/render-fn+opts [{:eval true} nextjournal.clerk.render/inspect-presented] {:path [0], :nextjournal/value "const x = VarF('x');\nconst f = AddF(\n  MulF(AddF(x, Const(2)), PowF(AddF(x, Const(3)), Const(2))),\n  NegF(SinF(x))\n);\n\nconsole.log('f(x)   =', printF(f));\nconsole.log('simp   =', printF(simplifyF(f)));\n\nconst df = diffF(f, 'x');\nconsole.log(\"f'(x)  =\", printF(df));\nconsole.log(\"simp'  =\", printF(simplifyF(df)));\n\nconsole.log('f(1)   =', run(f, evalAlg({ x: 1 })));\nconsole.log(\"f'(1)  =\", run(df, evalAlg({ x: 1 })));", :nextjournal/render-opts {:language "ts"}, :nextjournal/viewer {:name nextjournal.clerk.viewer/code-viewer, :render-fn #clerk/render-fn+opts [{:render-evaluator :sci} nextjournal.clerk.render/render-code], :hash "5dsJQw12yyyd7TcZEf52VSHxnqnJUC"}}]], :nextjournal/viewer {:name nextjournal.clerk.viewer/html-viewer, :render-fn #clerk/render-fn+opts [{:render-evaluator :sci} nextjournal.clerk.render/render-html], :hash "5drpr3yzJ1CcHNbRHnK2sVyn7YUmXB"}}] [:p [:<> "我终于发现："] [:strong [:<> "新增“操作”特别省心"]] [:<> "。再来一个 "] [:code [:<> "latexAlg"]] [:<> "、"] [:code [:<> "codegenAlg"]] [:<> "、"] [:code [:<> "freeVarsAlg"]] [:<> "……都只是写一张新的解释器表，表达式完全不用改。"]] ["h3" {:id "4.-这时候我开始怀疑：是不是语言的问题？"} [:<> "4. 这时候我开始怀疑：是不是语言的问题？"]] [:p [:<> "同样的思想，放到 Clojure，就像回了家。"]] [#clerk/render-fn+opts [{:eval true} nextjournal.clerk.render/inspect-presented] {:nextjournal/value [:div.code-viewer.code-listing [#clerk/render-fn+opts [{:eval true} nextjournal.clerk.render/inspect-presented] {:path [0], :nextjournal/value "(defn C-val [x] (fn [alg] ((:const alg) x)))\n(defn C-add [a b] (fn [alg] ((:add alg) (a alg) (b alg) alg)))\n\n(def eval-alg {:const identity\n               :add   (fn [a b _] (+ a b))})\n\n(def print-alg {:const str\n                :add   (fn [a b _] (str \"(\" a \") + (\" b \")\"))})\n\n(def e (C-add (C-val 42) (C-add (C-val 32) (C-val 10))))\n((e eval-alg))   ;=> 84\n((e print-alg))  ;=> \"(42) + ((32) + (10))\"", :nextjournal/render-opts {:language "clojure"}, :nextjournal/viewer {:name nextjournal.clerk.viewer/code-viewer, :render-fn #clerk/render-fn+opts [{:render-evaluator :sci} nextjournal.clerk.render/render-code], :hash "5dsJQw12yyyd7TcZEf52VSHxnqnJUC"}}]], :nextjournal/viewer {:name nextjournal.clerk.viewer/html-viewer, :render-fn #clerk/render-fn+opts [{:render-evaluator :sci} nextjournal.clerk.render/render-html], :hash "5drpr3yzJ1CcHNbRHnK2sVyn7YUmXB"}}] [:p [:<> "函数是一等公民，map 是解释器，关键字就是“方法名”。我在 TypeScript 里是"] [:strong [:<> "模拟"]] [:<> "这种结构；在 Clojure 里，只是"] [:strong [:<> "顺手"]] [:<> "。"]] [:p [:<> "如果我还想让「节点」和「操作」"] [:strong [:<> "两头都开放"]] [:<> "，Clojure 还有 "] [:strong [:<> "multimethods"]] [:<> "："] [#clerk/render-fn+opts [{:eval true} nextjournal.clerk.render/inspect-presented] {:nextjournal/value [:<> " "], :nextjournal/viewer {:name nextjournal.clerk.viewer/html-viewer, :render-fn #clerk/render-fn+opts [{:render-evaluator :sci} nextjournal.clerk.render/render-html], :hash "5drpr3yzJ1CcHNbRHnK2sVyn7YUmXB"}}] [:code [:<> "(defmulti exec (fn [op expr & _] [op (:tag expr)]))"]] [:<> " —— 新增节点=新 "] [:code [:<> ":tag"]] [:<> "；新增操作=新 "] [:code [:<> "op"]] [:<> "；旧代码不用动。这就是语言在帮我思考，而不是和我对抗。"]] ["h3" {:id "5.-回到那句老话"} [:<> "5. 回到那句老话"]] [:p [:strong [:<> "语言的边界，即思维的边界。"]] [#clerk/render-fn+opts [{:eval true} nextjournal.clerk.render/inspect-presented] {:nextjournal/value [:<> " "], :nextjournal/viewer {:name nextjournal.clerk.viewer/html-viewer, :render-fn #clerk/render-fn+opts [{:render-evaluator :sci} nextjournal.clerk.render/render-html], :hash "5drpr3yzJ1CcHNbRHnK2sVyn7YUmXB"}}] [:<> "在 TypeScript，我在"] [:strong [:<> "设计模式"]] [:<> "；在 Clojure，我在"] [:strong [:<> "描述计算"]] [:<> "；在 Haskell，我在"] [:strong [:<> "证明结构"]] [:<> "。"] [#clerk/render-fn+opts [{:eval true} nextjournal.clerk.render/inspect-presented] {:nextjournal/value [:<> " "], :nextjournal/viewer {:name nextjournal.clerk.viewer/html-viewer, :render-fn #clerk/render-fn+opts [{:render-evaluator :sci} nextjournal.clerk.render/render-html], :hash "5drpr3yzJ1CcHNbRHnK2sVyn7YUmXB"}}] [:<> "同一道题，不同语言给你不同的"] [:strong [:<> "默认思路"]] [:<> "。它们不是语法差异，而是"] [:strong [:<> "你能抵达的抽象边界"]] [:<> "。"]] [:p [:<> "我不是在教机器思考；我是在用语言，"] [:strong [:<> "教我自己"]] [:<> "思考。"]]], :nextjournal/visibility {:code :hide, :result :show}, :nextjournal/viewer {:name nextjournal.clerk.viewer/markdown-node-viewer, :render-fn #clerk/render-fn+opts [{:render-evaluator :sci} identity], :hash "5dsg4Bx9A9L7WvvCgamUoRtxUsmYCe"}, :nextjournal/render-opts {:id "pages.branchless/anon-expr-5drKAn88bXiz5cTM5eGacvLc551Jgv-result"}}, :nextjournal/blob-id "5dtC3XF3iiMAoUASrz9YZCoB2ZmY2x"}, :nextjournal/render-opts {:id "pages.branchless/anon-expr-5drKAn88bXiz5cTM5eGacvLc551Jgv-result"}, :nextjournal/visibility {:code :hide, :result :show}, :nextjournal/viewer {:name nextjournal.clerk.viewer/result-viewer, :render-fn #clerk/render-fn+opts [{:render-evaluator :sci} nextjournal.clerk.render/render-result], :hash "5dtGVHesd2XCTLFYF3aY4kJvkrX1x1"}}], :nextjournal/viewer {:name nextjournal.clerk.viewer/cell-viewer, :render-fn #clerk/render-fn+opts [{:render-evaluator :sci} (fn [xs opts] (into [:<>] (nextjournal.clerk.render/inspect-children opts) xs))], :hash "5dtX6xLh3vbeFdswBY6jLXmB8QTqo2"}}]}, :nextjournal/viewer {:name nextjournal.clerk.viewer/notebook-viewer, :render-fn #clerk/render-fn+opts [{:render-evaluator :sci} nextjournal.clerk.render/render-notebook], :hash "5duAFDxE4sCnRX71Wo6zeCpC9C3djE"}}